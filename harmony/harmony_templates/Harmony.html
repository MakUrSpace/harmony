<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="/bootstrap.min.css">
    <script src="/bootstrap.min.js"></script>
    <script src="/htmx.min.js"></script>

    <style>
        table,
        th,
        td {
            border: 1px solid black;
            padding: 15px;
        }

        .x-box {
            position: relative;
            display: flex;
        }

        .x-box::before,
        .x-box::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            /* Ensures it appears over text */
            pointer-events: none;
            /* Allows interactions with underlying content */
        }

        .x-box::before {
            background: linear-gradient(30deg, transparent 49%, red 49%, red 51%, transparent 51%);
        }

        .x-box::after {
            background: linear-gradient(-30deg, transparent 49%, red 49%, red 51%, transparent 51%);
        }
    </style>

    <title>Harmony</title>
</head>

<body>
    <div class="container">
        <h1 align="center">Harmony</h1>
        <hr>
        <div class="row" style="min-width: 500px">
            <div class="container justify-content-center" align="center">
                <h3 id="GameWorldHeader">Game World View -- {defaultCamera}</h3>
                <form id="selectPixelForm" hx-post="{harmonyURL}select_pixel" hx-target="#interactor">
                    <input type="hidden" name="selectedCamera" id="selectedCamera" value="{defaultCamera}">
                    <input type="hidden" name="selectedPixel" id="selectedPixel" value="">
                    <input type="hidden" name="appendPixel" id="appendPixel" value="false">
                    <input type="hidden" name="viewId" id="viewId" value="{viewId}">
                </form>
                <div id="GameWorldViewer" style="position: relative;">
                    <img id="GameWorld" class="img-responsive border border-3 border-info bg-primary"
                        src="{harmonyURL}camWithChanges/{defaultCamera}/{viewId}"
                        style="border-radius: 40px; max-width: 90%;">
                    <canvas id="GameWorldOverlay"
                        style="position:absolute; left:0; top:0; pointer-events:auto;"></canvas>
                </div>
                <script>
                    /**
                     * Initialize the Canvas Editor.
                     */
                    function initCanvasEditor(canvasId, data, onUpdate, onClick) {
                        const canvas = document.getElementById(canvasId);
                        const imgElem = document.getElementById('GameWorld');

                        if (!canvas || !imgElem) {
                            console.error("Canvas or Image not found");
                            return;
                        }

                        // Resize canvas to match image
                        function resizeCanvas() {
                            canvas.width = imgElem.clientWidth;
                            canvas.height = imgElem.clientHeight;
                            canvas.style.left = (imgElem.offsetLeft + imgElem.clientLeft) + "px";
                            canvas.style.top = (imgElem.offsetTop + imgElem.clientTop) + "px";
                            // Re-draw if needed
                            if (editor && editor.render) editor.render();
                        }

                        // Initial resize and listener
                        if (imgElem.complete) {
                            resizeCanvas();
                        } else {
                            imgElem.onload = resizeCanvas;
                        }
                        window.addEventListener('resize', resizeCanvas);
                        // Also resize periodically in case of layout shifts
                        setInterval(resizeCanvas, 1000);

                        const ctx = canvas.getContext('2d');
                        let isDragging = false;
                        let isClickCandidate = false;
                        let draggedObject = null;
                        let draggedPointIndex = -1;
                        const VERTEX_RADIUS = 5;

                        function getNaturalDims() {
                            const currentCam = document.getElementById('selectedCamera').value;
                            if (currentCam === "VirtualMap") {
                                return { w: 1200, h: 1200 };
                            }
                            return { w: 1920, h: 1080 };
                        }

                        function getScale() {
                            const dims = getNaturalDims();
                            // avoid div by zero
                            if (dims.w === 0 || dims.h === 0) return { x: 1, y: 1 };
                            return {
                                x: canvas.width / dims.w,
                                y: canvas.height / dims.h
                            };
                        }

                        function getMousePos(evt) {
                            const rect = canvas.getBoundingClientRect();
                            return {
                                x: (evt.clientX - rect.left) * (canvas.width / rect.width),
                                y: (evt.clientY - rect.top) * (canvas.height / rect.height),
                                originalEvent: evt
                            };
                        }

                        function dist(p1, p2) {
                            if (Array.isArray(p1)) p1 = { x: p1[0], y: p1[1] };
                            if (Array.isArray(p2)) p2 = { x: p2[0], y: p2[1] };
                            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                        }

                        function getPoly(objOrMap) {
                            if (!objOrMap) return null;
                            if (Array.isArray(objOrMap)) return objOrMap;
                            return objOrMap[document.getElementById(`selectedCamera`).value];
                        }


                        function drawPoly(poly, scale, fill = true, r = 255, g = 255, b = 0) {
                            // Draw vertices
                            // poly.forEach(p => {
                            //     const pt = Array.isArray(p) ? { x: p[0], y: p[1] } : p;
                            //     // Scale point to screen space
                            //     const screenPt = { x: pt.x * scale.x, y: pt.y * scale.y };

                            //     ctx.beginPath();
                            //     ctx.arc(screenPt.x, screenPt.y, VERTEX_RADIUS, 0, 2 * Math.PI);
                            //     ctx.fill();
                            //     ctx.stroke();
                            // });

                            // Draw edges
                            if (poly.length > 1) {
                                ctx.beginPath();
                                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0, 1)`;
                                ctx.lineWidth = 2;
                                var transparency = 0.3;
                                if (document.getElementById(`selectedCamera`).value == 'VirtualMap') {
                                    transparency = 1;
                                }
                                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${transparency})`;
                                const start = Array.isArray(poly[0]) ? { x: poly[0][0], y: poly[0][1] } : poly[0];
                                ctx.moveTo(start.x * scale.x, start.y * scale.y);
                                for (let i = 1; i < poly.length; i++) {
                                    const pt = Array.isArray(poly[i]) ? { x: poly[i][0], y: poly[i][1] } : poly[i];
                                    ctx.lineTo(pt.x * scale.x, pt.y * scale.y);
                                }
                                ctx.closePath();
                                if (fill) ctx.fill();
                                ctx.stroke();
                            }
                        }

                        function drawGroup(group, r, g, b, drawnSet) {
                            const scale = getScale();
                            group.forEach(name => {
                                if (drawnSet && drawnSet.has(name)) return;
                                if (data.objects[name]) {
                                    const poly = getPoly(data.objects[name]);
                                    if (!poly) return;
                                    drawPoly(poly, scale, true, r, g, b);
                                    if (drawnSet) drawnSet.add(name);
                                }
                            });
                        }

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const scale = getScale();
                            const drawnSet = new Set();

                            // selectable (lowest priority, “neutral hint”): RGB(180, 190, 205)

                            // terrain (background structure, stone/metal vibe): RGB(120, 125, 135)

                            // targetable (actionable, “UI accent” cyan): RGB(0, 200, 255)

                            // enemies (danger, strong red): RGB(230, 60, 70)

                            // allies (safe/positive, strong green): RGB(0, 210, 120)

                            // moveable (interactive edit mode, vivid purple): RGB(170, 80, 255)

                            // selection (highest priority, unmistakable gold): RGB(255, 210, 70)

                            if (data.moveable) {
                                drawGroup(data.moveable, 170, 80, 255, drawnSet);
                            }
                            if (data.allies) {
                                drawGroup(data.allies, 0, 210, 120, drawnSet);
                            }
                            if (data.enemies) {
                                drawGroup(data.enemies, 230, 60, 70, drawnSet);
                            }
                            if (data.targetable) {
                                drawGroup(data.targetable, 0, 200, 255, drawnSet);
                            }
                            if (data.terrain) {
                                drawGroup(data.terrain, 120, 125, 135, drawnSet);
                            }
                            if (data.selectable) {
                                drawGroup(data.selectable, 180, 190, 205, drawnSet);
                            }
                            if (data.selection) {
                                if (data.selection.additionalCells) {
                                    data.selection.additionalCells.forEach(cell => {
                                        const poly = getPoly(cell);
                                        if (poly) drawPoly(poly, scale, true, 255, 0, 255); // Magenta for additional
                                    });
                                }
                                if (data.selection.firstCell) {
                                    const poly = getPoly(data.selection.firstCell);
                                    if (poly) drawPoly(poly, scale, true, 255, 210, 70); // Gold for first
                                }
                            }
                        }

                        canvas.onmousedown = function (e) {
                            const m = getMousePos(e); // Screen coords
                            isClickCandidate = true;
                            const scale = getScale();

                            if (data.moveable) {
                                for (let name of data.moveable) {
                                    const objMap = data.objects[name];
                                    if (!objMap) continue;
                                    const poly = getPoly(objMap);
                                    if (!poly) continue;
                                    for (let i = 0; i < poly.length; i++) {
                                        const p = Array.isArray(poly[i]) ? { x: poly[i][0], y: poly[i][1] } : poly[i];
                                        // Convert point to screen space for check
                                        const p_screen = { x: p.x * scale.x, y: p.y * scale.y };

                                        if (dist(m, p_screen) <= VERTEX_RADIUS * 2) {
                                            isDragging = true;
                                            isClickCandidate = false; // It's a drag interaction
                                            draggedObject = name;
                                            draggedPointIndex = i;
                                            return;
                                        }
                                    }
                                }
                            }
                        };

                        canvas.onmousemove = function (e) {
                            if (isDragging && draggedObject) {
                                const m = getMousePos(e); // Screen coords
                                const scale = getScale();

                                const objMap = data.objects[draggedObject];
                                const poly = getPoly(objMap);

                                // Convert mouse screen coord back to image coord
                                const imagePt = { x: m.x / scale.x, y: m.y / scale.y };

                                if (Array.isArray(poly[draggedPointIndex])) {
                                    poly[draggedPointIndex] = [imagePt.x, imagePt.y];
                                } else {
                                    poly[draggedPointIndex] = imagePt;
                                }
                                if (onUpdate) onUpdate(data);
                                draw();
                            } else {
                                // If moving significantly without dragging, it's not a click
                                // (Optional refinement, skipping for simplicity)
                            }
                        };

                        canvas.onmouseup = function (e) {
                            if (isDragging) {
                                isDragging = false;
                                draggedObject = null;
                                draggedPointIndex = -1;
                            } else if (isClickCandidate) {
                                // Trigger click
                                if (onClick) onClick(e);
                            }
                            isClickCandidate = false;
                        };

                        canvas.onmouseleave = function () {
                            isDragging = false;
                            isClickCandidate = false;
                        };

                        draw();

                        return {
                            render: draw,
                            updateData: function (newData) {
                                Object.assign(data, newData);
                                draw();
                            }
                        };
                    }

                    // Existing logic adapted for external call
                    function handlePixelSelection(event) {
                        console.log("Canvas clicked!!", event);
                        // Event is the mouse event derived from canvas

                        // We need to match the original coordinate calculation
                        // original: event.x - left (where left is bounds.left)
                        // The event passed here is the mouseup event on the canvas.

                        const imgElem = document.getElementById(`GameWorld`)
                        const bounds = imgElem.getBoundingClientRect();

                        // Use clientX/Y for consistent screen coords
                        const clientX = event.clientX;
                        const clientY = event.clientY;

                        const left = bounds.left;
                        const top = bounds.top;

                        const x = clientX - left;
                        const y = clientY - top;

                        const cw = imgElem.clientWidth
                        const ch = imgElem.clientHeight

                        const selectedCamera = document.getElementById(`selectedCamera`).value
                        var natural_width = 1920
                        var natural_height = 1080
                        if (selectedCamera === "VirtualMap") {
                            natural_width = 1200
                            natural_height = 1200
                        }

                        // Safety check for div-by-zero
                        if (cw === 0 || ch === 0) return;

                        const px = x / cw * natural_width
                        const py = y / ch * natural_height

                        const image_x = px // (px - 0) * 1
                        const image_y = py // (py - 0) * 1

                        const pixelField = document.getElementById(`selectedPixel`)
                        const selectPixelForm = document.getElementById(`selectPixelForm`)
                        pixelField.value = JSON.stringify([~~image_x, ~~image_y])
                        selectPixelForm.requestSubmit()
                    }

                    // Initialization logic
                    const canvasData = {
                        objects: {},
                        moveable: [],
                        cameraName: document.getElementById('selectedCamera').value
                    };

                    var editor = null;

                    // Initialize once DOM is ready (or script runs)
                    // Since this script is at the end of the partial content, we can run it.
                    // But we should wait for the image to be ready for sizing, handled in init.
                    editor = initCanvasEditor("GameWorldOverlay", canvasData,
                        function (updatedData) { console.log("Data updated", updatedData); },
                        function (clickEvent) { handlePixelSelection(clickEvent); }
                    );

                    function gameWorldClick(camNum) {
                        const view_id = document.getElementById(`viewId`).value
                        var header = document.querySelector("#GameWorldHeader")
                        header.innerText = `Game World View -- ${camNum}`
                        var img = document.querySelector("#GameWorld")
                        img.src = `{harmonyURL}/camWithChanges/${camNum}/${view_id}`
                        const camField = document.getElementById(`selectedCamera`)
                        camField.value = camNum

                        // Update Editor Context
                        canvasData.cameraName = camNum;
                        if (editor) editor.render();
                    }

                    function syncCanvasData() {
                        viewId = document.getElementById("viewId").value;
                        fetch(`/harmony/canvas_data/{viewId}`)
                            .then(response => response.json())
                            .then(data => {
                                if (editor) {
                                    editor.updateData(data);
                                }
                            })
                            .catch(err => console.error("Error syncing canvas data:", err));
                    }
                    // Poll every 1 second (or trigger via HTMX event)
                    setInterval(syncCanvasData, 1000);
                </script>
            </div>
            <div class="container justify-content-center" align="center">
                {cameraButtons}
            </div>
            <div class="row justify-content-center" align="center" style="min-width: 500px">
                <div id="interactor" class="row"></div>
                <!-- <hr> removed -->
                <div id="objectTable" class="row">
                    <div id="objectFilterRetriever" hx-get="{harmonyURL}objects" hx-trigger="every 1s"
                        hx-target="#objectFilterRetriever"></div>
                </div>
                <div class="row">
                    <div class="col" align="left">
                        <form hx-post="{harmonyURL}save" hx-swap="none">
                            <input class="btn btn-success" type="submit" value="Save Game">
                            <input class="text" value="Harmony" id="game_name" name="game_name">
                        </form>
                    </div>
                    <div class="col" align="right">
                        <input class="btn btn-info" type="button" value="Configurator"
                            onclick="window.location.href='{configuratorURL}'">
                    </div>
                </div>
                <div class="row">
                    <div class="col" align="left">
                        <input class="btn btn-warning" type="submit" value="Load Game" onclick="loadGame()">
                        <form id="load_game" hx-post="{harmonyURL}load" hx-swap="none">
                            <input type="hidden" value="Harmony" id="load_game_name" name="game_name">
                        </form>
                        <script>
                            function load_game() {
                                const gameName = document.getElementById(`game_name`).value
                                const loadGameField = document.getElementById(`load_game_name`)
                                loadGameField.value = game_name
                                const loadGameForm = document.getElementById(`load_game`)
                                loadGameForm.requestSubmit()
                            }
                        </script>
                    </div>
                    <div class="col" align="center">
                        <button class="btn btn-info" onclick=" window.open('{harmonyURL}control','_blank')">Session
                            Control Panels</button>
                    </div>
                    <div class="col" align="right">
                        <input class="btn btn-danger" type="button" value="Reset Game" hx-get="{harmonyURL}reset">
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>